---
title: "Trabalho Final - Estatística Espacial"
author: "Alexandre Novaes Dornelas  \nJosé Carlos Maria Júnior  \nThiago Itamar Plum
  \ \nWalter Alves Moreira Barbosa dos Santos  \nWilliam Xavier dos Santos  \nYgor Silva Nascimento Coelho"
output: 
  html_document:
    toc: true
    toc_float: true
    number_sections: true
  pdf_document:
    toc: true
    number_sections: true
    keep_md: true

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,          # Não mostra código por padrão
  warning = FALSE,       # Não mostra warnings
  message = FALSE,       # Não mostra mensagens
  fig.align = 'center',  # Centraliza figuras
  fig.width = 5,         # Largura padrão das figuras
  fig.height = 5         # Altura padrão das figuras
)
```

<br>

# Estatística Espacial

## Preparação do ambiente e carregamento de bibliotecas

Esse passo é feito uma única vez para todo o script. Destaca-se que, a depender da instalação do usuário, pode ser necessária a instalação de pacotes adicionais. O comando a seguir "ativa" as funções do pacote.


```{r imports, echo=TRUE, results="hide", message=F, warning=F}
library(sf)         # manipulação de dados espaciais (shapefiles, CRS etc.)
library(readr)      # importação de arquivos CSV
library(dplyr)      # manipulação de bases de dados (tibbles, data.frames)
library(ggplot2)    # visualização de dados (mapas, gráficos)
library(leaflet)    # mapas interativos
library(gstat)      # geoestatística (variogramas e krigagem)
library(geobr)      # acesso a shapefiles do Brasil
library(sp)         # classes e funções para análise espacial tradicional
library(patchwork)  # para combinar/arrumar múltiplos gráficos juntos
library(readxl)
library(tmap)
library(stringr)
```

Em seguida, carregamos a base de dados fornecida para realizar a Análise Exploratória de Dados. A função read_excel() lê o arquivo e o armazena na variável 'dados'. Em seguida, iremos checar que o "tibble" foi carregado corretamente.


```{r load_data, echo=TRUE}
prices_df <- read_excel("base preco propriedade.xlsx")
glasgow_sf <- st_read("Glasgow.shp")
```

Podemos emitir alguns comandos para verificar que os dados foram carregados corretamente.

```{r check_data, echo=TRUE}
head(glasgow_sf)
st_crs(glasgow_sf)

head(prices_df)
str(prices_df)
summary(prices_df)
```

Por fim, podemos verificar se o shapefile foi carregado corretamente.

```{r check_shape, echo=TRUE}
ggplot(data = glasgow_sf) +
  geom_sf(fill = "white") +    # Preenche os bairros de branco
  theme_light()   
```
---

A partir dessa etapa, considera-se a preparação do ambiente terminada.

O próximo passo é a junção dos dados do shapefile na tabela original, bem como a padronização dos dados geográficos para evitar erros nas próximas etapas.

```{r normalize, echo=TRUE}

glasgow_dados <- left_join(x = prices_df,
                           y = glasgow_sf,
                           by = c("IZ" = "IZ"))
glasgow_dados  # Exibe o resultado
glasgow_dados <- st_as_sf(glasgow_dados)
class(glasgow_dados)

```

<div style="page-break-after: always;"></div>

# Questão 1: 

Crie um mapa coroplético estatático para a variável preço mediano dos imóveis com 5 faixas de amplitudes iguais.


```{r coropletico, echo=TRUE}
#Definindo o tipo do mapa como estático 
tmap_mode("plot")

# Mapa coroplético para o total de óbitos com intervalos por quantil
tm_shape(shp = glasgow_dados) +
  tm_polygons(
    fill = "preco",
    fill.scale = tm_scale_intervals(style = "quantile", n = 5, values = "brewer.greens"), # 5 classes por quantil
    fill.legend = tm_legend(title = "Preço Médio dos Imóveis em Glasgow")
  ) +
  tm_layout(frame = FALSE)
```

---

<div style="page-break-after: always;"></div>

# Questão 2: 

Crie um mapa coroplético interativo para a variável preço mediano dos imóveis com 8 faixas com amplitudes baseadas em quantis.

```{r interactive_map, echo=TRUE}
#Definindo o tipo do mapa como interativo 
tmap_mode("view") 

#Melhorando o grafico 
glasgow_dados = glasgow_dados |> 
  mutate(rotulo = str_c(name, " - ", preco))

tm_shape(shp = glasgow_dados) + 
  tm_polygons( # Adiciona polígonos preenchidos 
    fill = "preco", # Preenche polígonos pela variável 'preco' 
    fill.scale = tm_scale_intervals( style = "quantile", # define agrupamento com faixas baseada nos quantis 
                                     n = 8, # número de classes 
                                     values = "matplotlib.blues" # paleta de cores 
    ), 
    fill.legend = tm_legend(title = "Preço"), # Título da legenda 
    id = "rotulo", # Variável exibida ao passar o mouse (hover) 
    popup.vars = c("name", "preco"), # Variáveis exibidas no popup 
    lwd = 0.25 # Espessura da borda dos polígonos 
  )
```
